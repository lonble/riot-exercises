/*
 * Copyright (C) 2015 Inria
 * Copyright (C) 2023 TU Dresden
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @{
 *
 * @file
 * @author  Oliver Hahm <oliver.hahm@inria.fr>
 * @author  Martine Lenders <martine.lenders@tu-dresden.de>
 */

#include <stdio.h>
#include <string.h>

#include "msg.h"
#include "net/ipv6/addr.h"
#include "net/gnrc.h"
#include "net/gnrc/ipv6/hdr.h"
#include "net/utils.h"
#include "net/netif.h"
#include "od.h"
#include "shell.h"
#include "thread.h"
#include "ztimer.h"

#define MSG_QUEUE_SIZE 8

char receiver_stack[THREAD_STACKSIZE_DEFAULT];

/* [TASK 2: Move reception code to thread handler here] */
void *receiver(void *arg) {
    (void)arg;

    /* [TASK 1: include message queue initialization here] */
    msg_t msg_queue[MSG_QUEUE_SIZE];
    msg_init_queue(msg_queue, MSG_QUEUE_SIZE);

    /* [TASK 1: register for IPv6 protocol number 253 here] */
    gnrc_netreg_entry_t server = GNRC_NETREG_ENTRY_INIT_PID(253, thread_getpid());
    gnrc_netreg_register(GNRC_NETTYPE_IPV6, &server);

    /* [TASK 1: receive packet here] */
    while (1) {
        msg_t msg;
        msg_receive(&msg);
        if (msg.type == GNRC_NETAPI_MSG_TYPE_RCV) {
            gnrc_pktsnip_t *pkt = msg.content.ptr;

            // print packet header
            if (pkt->next) {
                if (pkt->next->next) {
                    // print link layer header
                    puts("=== Link layer header ===");
                    gnrc_netif_hdr_print(pkt->next->next->data);
                }
                /* print IPv6 header */
                puts("=== IPv6 header ===");
                ipv6_hdr_print(pkt->next->data);
            }

            /* print IPv6 payload */
            puts("=== IPv6 payload (hex) ===");
            od_hex_dump(pkt->data, pkt->size, OD_WIDTH_DEFAULT);
            puts("=== IPv6 payload (string) ===");
            printf("\"%.*s\"\n", pkt->size, (char *)pkt->data);

            // release the packet!!! or memory leaks
            gnrc_pktbuf_release(pkt);
        } else {
            // never reached
            puts("received unexpected message, ignore");
        }
    }

    // never reached
    /* [TASK 1: unregister from IPv6 protocol number 253 here] */
    gnrc_netreg_unregister(GNRC_NETTYPE_IPV6, &server);

    return NULL;
}

/* [TASK 2: Add shell command handler for sending here] */
int send_command(int argc, char **argv) {
    (void)argv;

    // check arguments count
    if (argc != 3) {
        puts("usage: send <IPv6 address> <message>");
        puts("Note: to send multiple words wrap the message in \"\"");
        return 1;
    }
    // parse address
    netif_t *netif = NULL;
    ipv6_addr_t addr;
    // netif will be set if dest is a link-local ipv6 address
    if (netutils_get_ipv6(&addr, &netif, argv[1]) != 0) {
        puts("Unable to parse IPv6 address\n");
        return 1;
    }

    gnrc_pktsnip_t *payload, *header;
    size_t payload_size = strlen(argv[2]);

    /* start packet with payload */
    payload = gnrc_pktbuf_add(NULL, argv[2], payload_size, GNRC_NETTYPE_UNDEF);
    if (payload == NULL) {
        puts("Unable to copy message to packet buffer");
        return 1;
    }
    /* add IPv6 header with payload as next header */
    header = gnrc_ipv6_hdr_build(payload, NULL, &addr);
    if (header == NULL) {
        puts("Unable to allocate IPv6 header");
        gnrc_pktbuf_release(payload);
        return 1;
    }
    /* set IPv6 next header to experimental protocol number 253 */
    ((ipv6_hdr_t *)(header->data))->nh = 253;

    // if dest is a link-local address, interface must be specified
    // this can be ignored if module "gnrc_netif_single" is used
    if (netif != NULL) {
        /* add link layer if netif is generated by argv[1] */
        gnrc_pktsnip_t *netif_hdr = gnrc_netif_hdr_build(NULL, 0, NULL, 0);
        if (netif_hdr == NULL) {
            puts("Unable to allocate netif header");
            gnrc_pktbuf_release(header);
            return 1;
        }
        /* set GNRC specific network interface values */
        gnrc_netif_hdr_set_netif(netif_hdr->data,
                                 container_of(netif, gnrc_netif_t, netif));
        /* prepend link layer header to IP packet */
        header = gnrc_pkt_prepend(header, netif_hdr);
    }

    // send packet
    int res = gnrc_netapi_dispatch_send(GNRC_NETTYPE_IPV6, GNRC_NETREG_DEMUX_CTX_ALL, header);
    if (!res) {
        printf("Unable to locate IP thread");
        gnrc_pktbuf_release(header);
        return 1;
    }

    return 0;
}

int main(void) {
    msg_t msg_queue[MSG_QUEUE_SIZE];
    msg_init_queue(msg_queue, MSG_QUEUE_SIZE);

    ztimer_sleep(ZTIMER_SEC, 3);

    puts("NETAPI example.\n");

    /* get interfaces and print their addresses */
    gnrc_netif_t *netif = NULL;
    while ((netif = gnrc_netif_iter(netif))) {
        printf("Iface %d:\n", (int)netif->pid);

        ipv6_addr_t ipv6_addrs[CONFIG_GNRC_NETIF_IPV6_ADDRS_NUMOF];
        int res = gnrc_netapi_get(netif->pid, NETOPT_IPV6_ADDR, 0, ipv6_addrs, sizeof(ipv6_addrs));

        if (res < 0) {
            puts(" {}");
            continue;
        }
        for (unsigned i = 0; i < (unsigned)(res / sizeof(ipv6_addr_t)); i++) {
            char ipv6_addr[IPV6_ADDR_MAX_STR_LEN];

            ipv6_addr_to_str(ipv6_addr, &ipv6_addrs[i], IPV6_ADDR_MAX_STR_LEN);
            printf("- %s\n", ipv6_addr);
        }
    }

    // create a thread to receive packets
    thread_create(receiver_stack, sizeof(receiver_stack), 5, 0, &receiver, NULL, "receiver");

    /* [TASK 2: register your shell command handler here] */
    /* buffer to read commands */
    char line_buf[SHELL_DEFAULT_BUFSIZE];
    shell_command_t commands[] = {
        {
            .name = "send",
            .desc = "Send a message over IPv6",
            .handler = &send_command,
        },
        { NULL, NULL, NULL },
    };
    /* run the shell, this will block the thread waiting for incoming commands */
    shell_run_forever(commands, line_buf, SHELL_DEFAULT_BUFSIZE);

    /* main thread exits */
    return 0;
}

/** @} */
