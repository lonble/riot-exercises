- 线程封装比较粗糙，用户不仅可以获得线程描述符，还可以获得线程控制块，甚至一些内部函数也是公开的
- 大部分函数都有两个版本，分别接受线程描述符和线程控制块
- 线程栈需要手动创建和管理，这也意味着线程之间是没有隔离的
- `THREAD_STACKSIZE_DEFAULT`是1K
- 线程都是detached的，虽然线程函数有返回值，类型为`void *`，但没有任何地方使用这个值，也不存在`join()`或`wait()`等操作
- 如果创建比当前线程优先级更高的线程，则自动切换到新线程。可以通过flag`THREAD_CREATE_WOUT_YIELD`抑制切换，但极短的时间内会有中断触发线程调度
- flag`THREAD_CREATE_SLEEPING`会让新线程默认处于未就绪状态，手动调用`thread_wakeup()`后才会就绪
- 调度方案比较原始，完全依赖于优先级，在任意时刻只有就绪的最高优先级的线程会运行，所以不存在并行，甚至没有并发
- 当前运行的线程只有主动调用`thread_yield()`或者被更高优先级的线程抢占cpu才会停止运行
- 由于以上两点，每一个线程都应该手动分配不同的优先级，并处理不同类型的任务。为相同任务创建多个worker极难同步，也没有意义
- 优先级从`0`到`15`，值越低优先级越高。优先级在线程创建时指定，并且不能更改。主线程的优先级为`7`
- `exit(0)`和`main`函数`return`的行为是不同的，并且都不能结束程序
- 程序默认除了主线程，还有一个后台线程，用于处理串口通信等任务，优先级是`1`
- 中断处理**不是**以线程的方式进行的，中断处理期间阻塞当前线程
- timer是中断处理而不是线程
